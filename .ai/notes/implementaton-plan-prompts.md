# Implementation Plan Prompts

This document provides a set of prompts designed to guide AI coding agents in creating implementation plans. The prompts are based on the architectural patterns, service layer design, and development practices established in the project. They can be used as inputs to the `/create-implementation-plan` prompt to generate actionable tasks for agents.

## Implementation Plan Prompts

![Status: Completed](https://img.shields.io/badge/status-Completed-green)

[**Accessible Form Component**](../plan/feature-accessible-form-component-1.md): Create a comprehensive Form component in `@sparkle/ui/src/components/Form/` using Radix UI's Form primitives, implementing FormProps interface extending HTMLProperties<HTMLFormElement> with variants for validation states (default, error, success), field types (text, email, password, textarea, select), and size options, using React.forwardRef pattern matching Button.tsx, exporting through index.ts chain, building Vitest tests covering accessibility features and form validation, and developing Storybook stories in `packages/storybook/src/stories/Form.stories.tsx` demonstrating ARIA labels, error messages, keyboard navigation, screen reader compatibility, and all variant combinations with comprehensive controls and documentation.

**Fro Bot Chat Integration**: Develop fro-jive mobile app to integrate with Fro Bot external API at https://github.com/fro-bot, implementing chat UI using `@sparkle/ui` components adapted for React Native, creating new chat-specific components in `apps/fro-jive/components/Chat/` (ChatBubble, MessageInput, VoiceRecorder), adding expo-speech and expo-av for voice interfaces, implementing real-time WebSocket or HTTP polling for message exchange, using `@sparkle/types` for message and user interfaces, `@sparkle/utils` for debouncing and state management, following Expo file-based routing in `app/(tabs)/chat.tsx`, ensuring cross-platform compatibility for web and mobile, implementing proper error handling with `@sparkle/error-testing` patterns, and adding offline support with local message storage.

[**Theme Management Package**](../plan/feature-theme-management-package-1.md): Create `@sparkle/theme` package with proper monorepo structure in `packages/theme/`, implementing ThemeProvider using React Context and `@sparkle/types` ThemeConfig interface, building design token system compatible with both Tailwind CSS (web) and React Native StyleSheet, creating theme.config.ts files that export CSS variables for web and style objects for mobile, integrating with existing Tailwind configuration in tailwind.config.ts and tailwind.config.ts, adding TypeScript project references in tsconfig.json, implementing theme switching functionality with useTheme hook in `@sparkle/utils`, demonstrating usage across all packages by updating Button and Form components in `@sparkle/ui` and Storybook stories in `@sparkle/storybook`, and ensuring proper build pipeline integration in turbo.json.

**Cross-Platform Notification System**: Implement notification system using `@sparkle/types` for NotificationConfig and NotificationState interfaces, creating useNotification hook in `@sparkle/utils` with methods for show, hide, and queue management, building NotificationProvider component in `@sparkle/ui` using React Context for web implementation, adapting notifications for React Native in fro-jive using expo-notifications for push notifications and custom toast components for in-app alerts, implementing error testing scenarios in `@sparkle/error-testing` using TestScenarioBuilder to validate network failures, permission denials, and queue overflow situations with proper recovery strategies, ensuring notifications work across web Storybook, fro-jive mobile app, and any future applications, and adding comprehensive tests covering accessibility, timing, and cross-platform consistency.

[**Astro Starlight Documentation Site**](../plan/feature-astro-starlight-docs-1.md): Create `@sparkle/docs` package in `docs/` using Astro Starlight with latest conventions, implementing automated component documentation extraction from JSDoc comments in `@sparkle/ui`, building interactive component playground using Astro Islands and Storybook embed integration, creating documentation structure mirroring package organization (ui, types, utils, error-testing, theme), implementing automated API reference generation from TypeScript interfaces, adding live code examples with syntax highlighting and copy-to-clipboard functionality, configuring deployment pipeline in workflows for automatic GitHub Pages deployment to https://sparkle.mrbro.dev, integrating search functionality with Starlight's built-in features, ensuring responsive design and accessibility compliance, and adding cross-links between documentation sections and actual package implementations.

[**Go Live Checklist and Testing Framework**](../plan/infrastructure-testing-framework-1.md): Develop comprehensive pre-deployment validation system by creating automated testing pipeline in workflows that runs bundle analysis using webpack-bundle-analyzer on all packages, implements end-to-end testing with Playwright covering critical user flows in fro-jive and Storybook, adds lighthouse CI for performance and accessibility auditing, creates deployment smoke tests verifying all package exports and cross-package imports, implements network failure simulation using MSW (Mock Service Worker) to test offline scenarios, adds browser compatibility testing across modern browsers, validates all external integrations (Fro Bot API, GitHub Pages), creates reusable checklist template in `docs/deployment-checklist.md` with automated verification scripts, and implements monitoring dashboard for tracking bundle sizes, build times, and test coverage across all packages with alerts for regressions.

## Advanced Follow-Up Implementation Prompts

**Advanced Component Architecture with Compound Patterns**: Design a sophisticated compound component system in `@sparkle/ui` that implements advanced patterns like render props, compound components (Menu.Root, Menu.Item, Menu.Separator), and polymorphic components using TypeScript's generic constraints and conditional types, exploring how to maintain type safety across complex component compositions while ensuring accessibility compliance and cross-platform compatibility, challenging the current forwardRef pattern by investigating alternatives like slot-based composition and investigating how compound patterns interact with React Native's platform-specific component requirements.

**Real-World Production Scalability Architecture**: Challenge the current experimental playground approach by designing a production-ready architecture that addresses enterprise concerns like micro-frontend integration, package versioning strategies for breaking changes, performance optimization at scale (code splitting, tree shaking, bundle analysis), security considerations for cross-package data flow, and CI/CD pipeline optimization for large teams, investigating whether the current Turborepo + pnpm workspace setup can handle hundreds of developers and thousands of components while maintaining the type safety and development experience standards established in the current codebase.

**Advanced Cross-Platform State Management and Data Flow**: Investigate implementing a sophisticated state management solution that bridges React Native, web, and potentially future platforms (like Tauri desktop apps), exploring patterns like Redux Toolkit with RTK Query for data fetching, Zustand for client state, and React Query for server state synchronization, challenging current assumptions about package boundaries by designing a unified data layer that works across `@sparkle/ui`, fro-jive mobile app, and documentation site while maintaining type safety and supporting real-time features like collaborative editing, live chat, and synchronized theme changes across all platforms and applications.

## Suggested Prompts for AI Development

When working with the Sparkle monorepo, consider using these focused prompts to leverage the comprehensive architecture and tooling:

### ðŸŽ¨ Theme System Development
"Create a new themed component following the Sparkle design system patterns. Use the TokenTransformer for cross-platform token conversion, implement proper theme context usage, and include comprehensive visual regression tests across light/dark themes and multiple viewports. Ensure the component works with both web and React Native platforms."

### ðŸ§ª Component Testing & Documentation
"Implement a complete testing suite for a Sparkle UI component including unit tests with Vitest type-checking, Storybook stories with theme switching controls and accessibility documentation, and Playwright visual regression tests. Follow the established patterns in packages/storybook/test/visual-regression/ and ensure proper error scenario coverage using TestScenarioBuilder."

### [ðŸš€ Monorepo Integration & Optimization](../plan/infrastructure-build-pipeline-1.md)
"Optimize the Sparkle monorepo build pipeline by analyzing Turborepo task dependencies, ensuring proper TypeScript project references between packages, and implementing efficient development workflows. Focus on cross-package type safety, build performance, and maintaining workspace consistency with manypkg validation."

## ðŸš€ Three Unique Implementation Plan Prompts (2025-09-30)

Here are three tailored implementation plan prompts to enhance and extend the Sparkle project:

### 1. Cross-Platform Component Migration System
Create an automated migration tool that analyzes components in `@sparkle/ui` and generates platform-specific adaptations for both the fro-jive mobile app and moo-dang web shell, ensuring consistent design system implementation across all platforms. The tool should parse existing React components, identify platform-incompatible patterns (like DOM-specific props or Web APIs), generate React Native equivalents with proper StyleSheet transformations using `@sparkle/theme`'s TokenTransformer, and create moo-dang-compatible versions that integrate with the xterm.js terminal interface. Include comprehensive test generation for each platform variant, validation against the existing Storybook stories, and documentation updates showing the component's behavior across web (Storybook), mobile (fro-jive), and terminal (moo-dang) environments.

### 2. WASM Command Plugin Ecosystem for moo-dang
Design and implement a plugin system for moo-dang that allows third-party developers to create custom shell commands as Zig WASM modules with a standardized API surface. This should include a command registry system that discovers and loads WASM plugins at runtime, an enhanced `shell_api.zig` with plugin lifecycle hooks (initialization, command parsing, execution, cleanup), a CLI scaffolding tool (`pnpm create moo-dang-command`) that generates boilerplate Zig code with proper shell API integration, and a marketplace-ready documentation site (integrated into the existing Astro Starlight docs) that showcases community plugins with live demos running in an embedded moo-dang instance. The system must maintain security boundaries through capability-based permissions, support hot-reloading during development, and provide TypeScript type definitions for the TypeScript/Zig bridge layer.

### 3. Visual Regression Testing Framework with AI-Assisted Baseline Management
Extend the existing Playwright visual regression testing infrastructure in visual-regression with an AI-powered baseline management system that intelligently identifies intentional design changes versus regressions. Implement a machine learning model (or integrate with existing services like Percy/Chromatic) that analyzes screenshot diffs, correlates them with recent commits in the theme system (`@sparkle/theme/src/tokens/`), and automatically categorizes changes as "theme update," "component enhancement," "layout shift," or "potential regression." Build a review dashboard integrated into the GitHub Actions workflow that presents visual changes grouped by category, allows developers to batch-approve intentional changes, and auto-generates changeset entries documenting visual API changes. The system should track design token mutations across all components, predict which components might be affected by theme changes before tests run, and provide accessibility impact analysis (contrast ratios, focus visibility) alongside visual comparisons.
